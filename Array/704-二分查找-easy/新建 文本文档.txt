// 题目强调是升序的整型数组，并且假设nums中的所有元素是不重复的
// 因此这里可以考虑二分查找法
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) { // 因为left == right是有意义的，所以使用 <=
            int middle =
                left + (right - left) / 2; // 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // 当前这个nums[middle]一定不是target，所以middle - 1
            } else if (nums[middle] < target) {
                left = middle + 1; // 当前这个nums[middle]一定不是target，所以middle + 1
            } else {           // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        return -1; // 未找到目标值
    }
};
// 时间复杂度：O(log n)
// 二分查找法是非常重要的基础算法，但是要注意>、>=、<、<=等符号的书写
// 还要注意是right = middle - 1;还是right = middle;
// 这里就涉及到是左闭右闭还是左闭右开了
// 总而言之，这是一个非常简单且重要的算法，但是对于边界的理解要深刻且记忆